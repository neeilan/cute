{"version":3,"sources":["assembler.js","example_programs.js","cute.js","MachineStateView.js","App.js","reportWebVitals.js","index.js"],"names":["lex","source","tokens","currTok","inComment","split","forEach","c","length","token","join","trim","push","indexOf","assemble","machine","out","code","disasm","slice","labels","labelNum","i","opStr","op","OPS","undefined","Error","toString","opMeta","OPCODES","name","label","parseInt","str","j","splice","charCodeAt","args","arg","argAsInt","REGISTER_NUMS","isNaN","varLen","numVarArgs","k","varArg","console","log","memLoad","memory","addr","contents","b","module","exports","loadAtAddr","asm","REGISTER_NAMES","0","1","2","3","4","5","6","7","8","num","desc","9","10","11","12","13","14","15","16","17","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","HALT","ADD","ADDI","SUB","SUBI","ASSERT","LABEL","JMPL","JMPGT","JMPGTE","JMPEQ","PRINT","SETI","JMPI","JMPEQI","JMPEQIL","PRINTBYTE","DATA","PRINTSTRL","PRINTBYTEI","JMPEQL","SET","JMPLT","JMPLTE","LOAD","PUSH","POP","CALL","RET","CHDATA","STORE","AOL","STORI","JMPNEQIL","MUL","MULI","DIV","DIVI","PCALL","PRET","numArgs","Object","keys","char","_execute","registers","codeStart","codeEnd","oneStep","print","_labels","_statics","currInstr","opCode","lhs","rhs","rip","alert","Math","floor","String","fromCharCode","byteToPrint","topOfStack","ra","registerStateAtCallTime","pcall_args","registerStateAtReturnTime","retVals","v","CuteMachine","this","execute","executeStep","setIp","val","Assemble","require","EXAMPLE_PROGRAMS","STYLES","MachineStateView","props","Array","fill","numAddrsToDisplay","numBytesPerRow","state","memDisplayStartAddr","asmArea","loadAddr","disasmTokens","disasmIsFresh","docInstr","setState","e","newAddr","instrs","entries","meta","bytes","memTable","ripValueAdj","RIP","rspValueAdj","RSP","rbpValueAdj","RBP","_","cols","style","backgroundColor","map","offset","dynaColor","absoluteAddr","disasmAvailable","overflow","className","type","width","border","onChange","memSet","target","value","disabled","Container","Row","textAlign","Col","md","marginBottom","Table","bordered","responsive","size","isRip","isRsp","isRbp","regSet","Button","variant","onClick","run","marginLeft","step","memPrev","memNext","paddingLeft","inspectAddr","placeholder","marginTop","sm","height","minHeight","borderColor","asmAreaEdit","InputGroup","FormControl","setLoadAddr","Append","overflowY","p","Badge","pill","availableInstrs","instr","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.17ec8c0f.chunk.js","sourcesContent":["function lex(source) {\n    const tokens = [];\n    let currTok = [];\n    let inComment = false;\n\n    source.split('').forEach(c => {\n        if (c == '\\n') {\n            inComment = false;\n        }\n        if (inComment) { return; }\n        if (c == '#') {\n            inComment = true;\n            return;\n        } else if ((c == ' ' || c == '\\n') && currTok.length > 0) {\n            var token = currTok.join('').trim();\n            if (!token) return;\n            tokens.push(token);\n            currTok = [];\n        } else if (['\\t', ''].indexOf(c) === -1) {\n            currTok.push(c);\n        }\n    });\n\n    if (!inComment) {\n        var token = currTok.join('').trim();\n        if (!token) return tokens;\n        tokens.push(token);\n    }\n\n    return tokens;\n}\n\nfunction assemble(tokens, machine, out={}) {\n    const code = [];\n    out.disasm = tokens.slice();\n    const labels = {}; let labelNum = 1;\n    let i = 0;\n    while (i < tokens.length) {\n        const opStr = tokens[i];\n        const op = machine.OPS[opStr];\n        if (op === undefined) {\n            throw new Error(\"Parsing error. Expected op at index \" + i.toString() + \" but got \" + opStr);\n        }\n        let opMeta = machine.OPCODES[op];\n        if (opMeta.name === \"DATA\") {\n            const label = tokens[i+1];\n            labels[label] = labelNum++;\n            const length = parseInt(tokens[i+2]);\n            i += length;\n        } else if (opMeta.name === \"CHDATA\") {\n            const label = tokens[i+1];\n            labels[label] = labelNum++;\n            const length = parseInt(tokens[i+2]);\n            const str = tokens[i+3].split('');  // TODO: Do we really need size here?? Can be implicit.\n            for (let j = 0; j < length; j++) {\n                tokens.splice(i + j + 3, 0, str[j].charCodeAt(0));\n            }\n            tokens.splice(i + str.length + 3, 1);\n\n            // Keep original chars in disassembly\n            out.disasm = tokens.slice();\n            for (let j = 0; j < length; j++) {\n                out.disasm[i + j + 3] = str[j];\n            }\n            i += length;\n        } else if (opMeta.name == \"LABEL\") {\n            const label = tokens[i+1];\n            labels[label] = labelNum++;\n        } else if (opMeta.name === \"AOL\") {\n            const labelNum = labels[tokens[i+1]];\n            if (labelNum === undefined) {\n                throw new Error('Usage of undefined label: ' + tokens[i+2].toString());\n            }\n            tokens[i+1] = labelNum;\n        }\n        i += opMeta.args + 1;\n    }\n    i = 0;\n\n    while (i < tokens.length) {\n        const opStr = tokens[i];\n        const op = machine.OPS[opStr];\n        if (op === undefined) {\n            throw new Error(\"Parsing error. Expected op at index \" + i.toString() + \" but got \" + opStr);\n        }\n\n        code.push(op);\n        let opMeta = machine.OPCODES[op];\n        let j = 0;\n        while (j++ < opMeta.args) {\n            if (i + j >= tokens.length) {\n                throw new Error(\"Parse runs past code area\");\n            }\n            const arg = tokens[i + j];\n            const argAsInt = parseInt(arg);\n            if (machine.REGISTER_NUMS[arg] !== undefined) {\n                code.push(machine.REGISTER_NUMS[arg]);\n            } else if (isNaN(argAsInt) && labels[arg] !== undefined) { // labels cannot start w a number\n                code.push( labels[arg] );\n            } else {\n                code.push( parseInt(arg) );\n            }\n\n            if (opMeta.varLen && j === opMeta.args) {\n                // Fixed args parsed - last one is number of true args which we parse now\n                const numVarArgs = code[code.length-1];\n                for (let k = 1; k <= numVarArgs; k++) {\n                    const varArg = tokens[i + j  + k];\n                    code.push(parseInt(varArg));\n                }\n                i += numVarArgs;\n            }\n        }\n        i += opMeta.args + 1;\n    }\n    console.log(labels);\n    return code;\n}\n\nfunction memLoad(memory , addr, contents) {\n    if (addr + contents.length > memory.length) {\n        throw new Error(`Not enough memory to load ${memory.length} bytes at ${addr}`)\n    }\n    contents.forEach((b, i) => memory[addr + i] = b);\n    return memory;\n}\n\nfunction memLoadWillOverwrite(memory , addr, contents) {\n    for (let i = 0; i < contents.length; i++) {\n        if (addr + contents.length > memory.length) {\n            throw new Error(`Not enough memory to load ${memory.length} bytes at ${addr}`)\n        }\n\n        if (memory[addr + i] !== 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst Assemble = function(machine, source, loadAtAddr=0) {\n    const tokens = lex(source);\n    let out = {};\n    const asm = assemble(tokens, machine, out);\n    memLoad(machine.memory, loadAtAddr, asm);\n    return out.disasm;\n };\n\nmodule.exports = Assemble;\n\n","const PRINT_1_TO_10 = `SETI R0 0\nLABEL INCRANDPRINT\nADDI R0 1\nPRINT R0\nJMPEQIL R0 10 DONE\nJMPL INCRANDPRINT\nLABEL DONE\n`;\n\nconst PRINT_SUM_1_TO_10 = `# Print sum of all numbers from 1 to 10\n# R0 is total, R1 is loop var\nSETI R0 0\nSETI R1 1\nLABEL ADDANDINCR\nADD R0 R1\nADDI R1 1\nJMPEQIL R1 11 PRINTRES\nJMPL ADDANDINCR\nLABEL PRINTRES\nPRINT R0`;\n\nconst REC_FACTORIAL = `SETI R0 4  # Calculate factorial(4). Try changing the arg!\nPUSH R0\nPCALL FACTORIAL\nPOP R0\nPRINT R0\nHALT\n\nLABEL FACTORIAL\nPOP R0          # R0 is the arg\nSETI R1 2\nJMPLT R0 R1 ret1\n\n# non-trivial factorial\nSETI R2 0\nADD R2 R0 # R2 is the result\n\n# find factorial of R0 (arg) - 1\nSUBI R0 1\nPUSH R0\nPCALL FACTORIAL\nPOP R3\n\n# Answer is [original] R0 * factorial of [original] R0 - 1\nMUL R2 R3\nPUSH R2\nPRET\n\n# trivial case - return 0\nLABEL ret1\nSETI R0 1\nPUSH R0\nPRET `;\n\nconst DIGIT_ADDER = `# This program adds an arbitrarily long addition expression of single\n# digit numbers. To change arg, change the length of the expression\n# and change the expression below. For example, try, changing the line\n# below to:  CHDATA src 9 3+4+9+1+2\nCHDATA src 5 3+4+4\n\nAOL src R0  # R0 has address of src\nADDI R0 1   # next char, so pointing at first char\nPUSH R0\nPCALL EXPR\nPOP R0\nPRINT R0\nHALT\n\nLABEL EXPR\n    POP R1      # R1 is address to start at\n    LOAD R2 R1  # R2 is char to parse\n    PUSH R2\n    PCALL PARSENUM\n    POP R2      # R2 is parsed LHS\n\n    ADDI R1 1    # R1 is *Operator\n    LOAD R3 R1   # R4 is the Operator\n\n    JMPNEQIL R3 43 done # Not an addition (43 is '+')\n    ADDI R1 1\n    PUSH R1\n    PCALL EXPR\n    POP R1\n    ADD R2 R1\n\n    LABEL done\n    PUSH R2\n    PRET   \n\nLABEL PARSENUM\n    POP R1\n    SUBI R1 48\n    PUSH R1\n    PRET`;\n  \n\nmodule.exports = [{\n    name: 'Print nums from 1 to 10',\n    source: PRINT_1_TO_10,\n},\n{\n    name: 'Sum numbers from 1 to 10',\n    source: PRINT_SUM_1_TO_10\n},\n{\n    name: 'Digit parser and adder',\n    source: DIGIT_ADDER\n},\n{\n    name: 'Recursive factorial',\n    source: REC_FACTORIAL\n}];","const REGISTER_NAMES = {\n  0 : 'R0',\n  1 : 'R1',\n  2 : 'R2',\n  3 : 'R3',\n  4 : 'R4',\n  5 : 'RRA',\n  6 : 'RBP',\n  7 : 'RSP',\n  8 : 'RIP',\n};\n\n// Reverse mapping of REGISTER_NAMES\nconst REGISTER_NUMS = {};\nfor (let num in REGISTER_NAMES) {\n  REGISTER_NUMS[REGISTER_NAMES[num]] = num;\n}\n\nconst OPCODES = {\n  0: { name: 'HALT', args: 0, desc: 'Args: none  -  Stops execution of the program here. Does not advance IP' },\n  1: { name: 'ADD', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 + Reg2' },\n  2: { name: 'ADDI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg + Immediate' },\n  3: { name: 'SUB', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 - Reg2'  },\n  4: { name: 'SUBI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg - Immediate' },\n  // 5: { name: 'ASSERT', args: 1 , desc: '' },\n  6: { name: 'LABEL', args: 1 , desc: 'Args: <Label>  -  Creates a label with given name, pointing to next instruction' },\n  7: { name: 'JMPL', args: 1 , desc: 'Args: <Label> - Unconditional jump to the label with given name' },\n  8: { name: 'JMPGT', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 > Reg2' },\n  9: { name: 'JMPGTE', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 >= Reg2' },\n  10: { name: 'JMPEQ', args: 3 , desc: 'Args: <Reg1> <Reg2> <Immediate> - Conditional jump to Immediate address if Reg1 equals Reg2' },\n  11: { name: 'PRINT', args: 1 , desc: 'Args: <Reg> - Print the value of Reg' },\n  12: { name: 'SETI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Immediate' },\n  13: { name: 'JMPI', args: 1 , desc: 'Args:  <Address> - Unconditional jump to Address' },\n  14: { name: 'JMPEQI', args: 3 , desc: 'Args: <Reg> <Address1> <Address2> - If Reg = value at Address1, jump to Address2' },\n  15: { name: 'JMPEQIL', args: 3 , desc: 'Args: <Reg> <Address> <Label>  -  If value of Reg equals Immediate, jump to Label' },\n  16: { name: 'PRINTBYTE', args: 1 , desc: 'Args: <Reg> - PRINT, but Reg is a register contaiing address of byte to print' },\n  17: { name: 'DATA', args: 2, varLen: true , desc: 'VarArgs: <Label> <Length> [Bytes] - Defines static data of given Length, with given Label' },\n  // 18: { name: 'PRINTSTRL', args: 1 , desc: '' },\n  19: { name: 'PRINTBYTEI', args: 1 , desc: 'Args: <Immediate> - Prints ASCII character for the given immediate' },\n  20: { name: 'JMPEQL', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 = Reg2' },\n  21: { name: 'SET', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets value Reg1 to the value of Reg2' },\n  22: { name: 'JMPLT', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 < Reg2' },\n  23: { name: 'JMPLTE', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 <= Reg2' },\n  24: { name: 'LOAD', args: 2 , desc: 'Args: <Reg1> <Reg2> - Load byte at address held in Reg2 into Reg1' },\n  25: { name: 'PUSH', args: 1 , desc: 'Args: <Reg> - Pushes the value of Reg to the top of the stack (RSP) and increments RSP' },\n  26: { name: 'POP', args: 1 , desc: 'Args: <Reg>  - Places the value on top of the stack (RSP-1) into Reg and decrements RSP' },\n  27: { name: 'CALL', args: 1 , desc: 'Args: <Label>  -  Pushes RRA onto the stack, sets RRA to next instruction, and jumps to Label' },\n  28: { name: 'RET', args: 0 , desc: 'Args: None  -  Returns control to the instruction at address RRA. Restores RRA to previous RRA value, which is expected to be on top of the stack (RSP-1)' },\n  29: { name: 'CHDATA', args: 2, varLen: true , desc: 'Varargs: <Label> <Length> STRING - Like DATA, but var-length data arg is provided as a character string. Eg. - CHDATA letters 5 ABCDE' },\n  30: { name: 'STORE', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Stores value of Reg1 at address held in Reg2' },\n  31: { name: 'AOL', args: 2 , desc: 'Args: <Label> <Register>  -  Address-of-label instruction. Sets Register to address Label refers to' },\n  32: { name: 'STORI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Stores Immediate value at address held in Reg' },\n  33: { name: 'JMPNEQIL', args: 3 , desc: 'Args: <Reg> <Immediate> <Label>  -  If value of Reg does not equal Immediate, jump to Label' },\n  34: { name: 'MUL', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 * Reg2' },\n  35: { name: 'MULI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg * Immediate' },\n  36: { name: 'DIV', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 / Reg2'  },\n  37: { name: 'DIVI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg / Immediate' },\n  38: { name: 'PCALL', args: 1 , desc: 'Preserved call. Like CALL, but preserves all registers' },\n  39: { name: 'PRET', args: 0 , desc: 'RET equivalent for PCALL - restores all preserved registers' },\n\n\n};\n\nconst OPS = {\n  HALT : 0,\n  ADD : 1,\n  ADDI : 2,\n  SUB : 3,\n  SUBI : 4,\n  ASSERT : 5,\n  LABEL : 6,\n  JMPL : 7,\n  JMPGT : 8,\n  JMPGTE : 9,\n  JMPEQ : 10,\n  PRINT : 11,\n  SETI   : 12,\n  JMPI : 13,\n  JMPEQI : 14,\n  JMPEQIL : 15,\n  PRINTBYTE : 16,\n  DATA : 17, // DATA HELLOWORLD SIZE  'H' 'E'\n  PRINTSTRL : 18, // Print a string at a label\n  PRINTBYTEI : 19,\n  JMPEQL : 20,\n  SET : 21,\n  JMPLT: 22,\n  JMPLTE : 23,\n  LOAD: 24,\n  PUSH : 25,\n  POP : 26,\n  CALL : 27,\n  RET : 28,\n  CHDATA : 29,\n  STORE : 30,\n  AOL : 31,\n  STORI : 32,\n  JMPNEQIL: 33,\n  MUL : 34,\n  MULI : 35, \n  DIV : 36,\n  DIVI : 37,\n  PCALL : 38,\n  PRET : 39,\n};\n\nconst\n    HALT = 0,\n    ADD = 1,\n    ADDI = 2,\n    SUB = 3,\n    SUBI = 4,\n    ASSERT = 5,\n    LABEL = 6,\n    JMPL = 7,\n    JMPGT = 8,\n    JMPGTE = 9,\n    JMPEQ = 10,\n    PRINT = 11,\n    SETI   = 12,\n    JMPI = 13,\n    JMPEQI = 14,\n    JMPEQIL = 15,\n    PRINTBYTE = 16,\n    DATA = 17, // DATA HELLOWORLD SIZE  'H' 'E'\n    PRINTSTRL = 18, // Print a string at a label\n    PRINTBYTEI = 19,\n    JMPEQL = 20,\n    SET = 21,\n    JMPLT = 22,\n    JMPLTE = 23,\n    LOAD = 24,\n    PUSH = 25,\n    POP = 26,\n    CALL = 27,\n    RET = 28,\n    CHDATA = 29,\n    STORE = 30,\n    AOL = 31,\n    STORI = 32, \n    JMPNEQIL = 33,\n    MUL = 34,\n    MULI = 35, \n    DIV = 36,\n    DIVI = 37,\n    PCALL = 38,\n    PRET = 39;\n\nconst numArgs = [];\nObject.keys(OPCODES).forEach(k => numArgs[k] = OPCODES[k].args);\n\nconst registers = [0, 0, 0, 0, 0, 0, 0, 0];\nconst R0 = 0, R1 = 1, R2=2, R3=3, R4=4, RRA=5, RBP= 6, RSP=7, RIP=8;\n\n\nlet memory = [\n  SETI, R1, 1, JMPI, 8, ADDI, R1, 5, ADDI, R1, 8, PRINT, R1, LABEL, 'ADD3MORE', ADDI, R1, 3, PRINT, R1\n];\n\n// Let's try a hello world\nconst c =  char =>  char.charCodeAt(0);\nmemory = [\n  DATA, \"HW\", 11, c('H'), c('e'), c('l'), c('l'), c ('o'), c(' '), c('W'), c('o'), c('r'), c('l'), c('d'),\n  SETI, R0, 11, // Length of str\n  SETI, R1, 0,  // Curr idx in str\n  SETI, R2, 3,  // Address of start of string \n  LABEL, \"PRINTCHAR\",\n  SET, R3, R2, // R3 is a temp we used to calculate start of string + curr index\n  ADD, R3, R1,\n  PRINTBYTE, R3,\n  ADDI, R1, 1,\n  JMPEQL, R1, R0, \"DONE\",\n  JMPL, \"PRINTCHAR\",\n  LABEL, \"DONE\",\n  \n];\n\n\nfunction _execute(memory, registers, codeStart, codeEnd, oneStep, print) {\n  // Find labels and static data in the code\n  const _labels = {};\n  const _statics = {};\n  let currInstr = codeStart;\n  while (currInstr < codeEnd) {\n    const opCode = memory[currInstr];\n    if (opCode === LABEL) {\n      _labels[ memory[currInstr + 1] ] = currInstr + numArgs[opCode] + 1;\n      currInstr += numArgs[opCode] + 1;\n    } else if (opCode === DATA || opCode === CHDATA) {\n      const label =  memory[currInstr + 1]; \n      _statics[ label ] = currInstr  + 2; // label points to the size byte\n      currInstr +=  1 + 2 + memory[ _statics[label] ] ;\n    } else {\n      currInstr += numArgs[opCode] + 1;\n    }\n  }\n\n  // Execute\n  let lhs = 0, rhs = 0; // Utility vars\n  while (registers[RIP] < codeEnd) {\n    var rip = registers[RIP];\n    switch (memory[rip]) {\n      case HALT:\n        // registers[RIP] += numArgs[memory[rip]] + 1;\n        return;\n      case PRINT:\n        print(registers[memory[rip + 1]]);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case ADD: // Adds two registers\n        registers[memory[rip + 1]] += registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case ADDI:\n        registers[memory[rip + 1]] += memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SUB: \n        registers[memory[rip + 1]] -= registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SUBI:\n        registers[memory[rip + 1]] -= memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case MUL: \n        registers[memory[rip + 1]] *= registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case MULI:\n        registers[memory[rip + 1]] *= memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case DIV: \n        rhs = registers[memory[rip + 2]];\n        if (rhs === 0) { alert('SIGFPE - division by 0'); return; }\n        registers[memory[rip + 1]] = Math.floor(registers[memory[rip + 1]] / rhs);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case DIVI:\n        rhs = memory[rip + 2];\n        if (rhs === 0) { alert('SIGFPE - division by 0'); return; }\n        registers[memory[rip + 1]] = Math.floor(registers[memory[rip + 1]] / rhs);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SET:\n        registers[memory[rip + 1]] = registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SETI:\n        registers[memory[rip + 1]] = memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case JMPI:\n        registers[RIP] = memory[rip + 1];\n        break;\n      case JMPL:\n        registers[RIP] = _labels[memory[rip + 1]];\n        break;\n      case LABEL:\n        // noop\n       registers[RIP] += 2;\n       break;\n      case JMPEQ:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs === rhs) {\n          registers[RIP] = memory[rip + 3];\n        } else {\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n        break;\n      case JMPEQI:\n        lhs = registers[memory[rip + 1]];\n        rhs = memory[rip + 2];\n        if (lhs === rhs) {\n          registers[RIP] = memory[rip + 3];\n        } else {\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case JMPGT:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs > rhs) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n       case JMPGTE:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs >= rhs) {\n          registers[RIP] = registers[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n       case JMPLT:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs < rhs) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n        break;\n       case JMPLTE:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs <= rhs) {\n          registers[RIP] = registers[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case JMPEQIL:\n      case JMPNEQIL:\n        lhs = registers[memory[rip + 1]];\n        rhs = memory[rip + 2];\n        let truthy = memory[rip] === JMPEQIL ? lhs === rhs : lhs !== rhs;\n        if (truthy) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case AOL:  // AOL label register\n        // Puts the address of label label in register\n        let addr = _statics[memory[rip + 1]];\n        if (addr === undefined) {\n          addr = _labels[memory[rip + 1]];\n        } // TODO: labels and statics can be one case\n        registers[memory[rip + 2]] = addr;\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case JMPEQL:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[ memory[rip + 2] ];\n        if (lhs === rhs) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case PRINTBYTEI:\n        print(String.fromCharCode( memory[rip + 1]  ) );\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case PRINTBYTE:\n        const byteToPrint = memory[registers[ memory[rip+1] ] ]; // Arg is a register contaiing address of byte to print\n        print( String.fromCharCode( byteToPrint  ) );\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case DATA:\n      case CHDATA:\n        // Noop\n        const label =  memory[rip + 1]; \n        registers[RIP] +=  2 + memory[ _statics[label] ]  +  1 ; // label, size, num of chars, +1 offset\n        break;\n      case LOAD:\n        registers[memory[rip+1]] = memory[registers[memory[rip+2]]];\n        console.log(`Load ${memory[registers[memory[rip+2]]]} into R${memory[rip+1]}`);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case STORE: // Store value of first arg (reg) into memory pointed to by second ard\n        memory[registers[memory[rip+2]]] = registers[memory[rip+1]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case STORI: // Store value of first arg (reg) into memory pointed to by second ard\n        memory[registers[memory[rip+2]]] = memory[rip+1];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case PUSH:\n        memory[registers[RSP]++] = registers[memory[rip+1]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case POP:\n        const topOfStack = registers[RSP] - 1;\n        registers[memory[rip+1]] = memory[topOfStack];\n        registers[RSP] = topOfStack;\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case CALL:\n        // First push RRA to stack\n        memory[registers[RSP]++] = registers[RRA];\n        // Write addr of next instruction to RRA\n        registers[RRA] = registers[RIP] + numArgs[memory[rip]] + 1;\n        // Jump to label\n        registers[RIP] = _labels[memory[rip + 1]];\n        break;\n      case RET:\n        // Pop stack RA into RRA, then jump there\n        const ra = registers[RRA];\n        registers[RRA] = memory[--registers[RSP]];\n        registers[RIP] = ra;\n        break;\n      case PCALL:\n        // Write addr of next instruction to RIP - we'll preserve this\n        registers[RIP] = registers[RIP] + numArgs[memory[rip]] + 1;\n        const registerStateAtCallTime = [...registers];\n\n        // Everything between [RBP and RSP) is an arg\n        let pcall_args = [];\n        for (let i = registers[RBP]; i < registers[RSP]; i++) {\n          pcall_args.push(memory[i]);\n        }\n\n        // This is important because when we restore RSP, we don't how how many args were provided for the call.\n        // Setting it 'minus args' here will let us simply increment by the number of return values in PRET.\n        registerStateAtCallTime[RSP] -= pcall_args.length;\n\n        // Preserve registers\n        for (let i = 0; i < registerStateAtCallTime.length; i++) {\n          memory[registers[RBP] + i] = registerStateAtCallTime[i];\n        }\n\n        // BP is where first arg sits\n        // Put args on top\n        for (let i = 0; i < pcall_args.length; i++) {\n          memory[registers[RBP] + registers.length + i ] = pcall_args[i];\n        }\n\n        registers[RBP] = registers[RBP] + registers.length;\n        registers[RSP] = registers[RSP] + registers.length;\n\n        pcall_args.splice(0, pcall_args.length);\n\n        // Jump to label\n        registers[RIP] = _labels[memory[rip + 1]];\n        break;\n      case PRET:\n        const registerStateAtReturnTime = [...registers];\n        // Gather retvals\n        let retVals = [];\n        for (let i = registerStateAtReturnTime[RBP]; i < registerStateAtReturnTime[RSP]; i++) {\n          retVals.push(memory[i]);\n        }\n\n        // Restore regs\n        for (let i = 0; i < registerStateAtReturnTime.length; i++) {\n          registers[i] = memory[ registerStateAtReturnTime[RBP] - registers.length + i ];\n        }\n        // Push retvals and adjust SP\n        retVals.forEach(v => {\n          memory[registers[RSP]] = v;\n          registers[RSP]++;\n        });\n\n        retVals.splice(0, retVals.length);\n\n        break;\n    }\n\n    if (oneStep) break;\n  } \n}\n\n// execute(0, memory.length);\n\nfunction CuteMachine(memory, print=console.log) {\n  this.registers = [0, 0, 0, 0, 0, 0, 64, 64, 0];\n  this.memory = memory;\n  this.print=print;\n\n  this.execute = () => _execute(this.memory, this.registers, 0, this.memory.length, false, print);\n  this.executeStep = () => _execute(this.memory, this.registers, 0, this.memory.length, true, print);\n  this.setIp = (val) => this.registers[ this.REGISTER_NUMS['RIP'] ] = val;\n\n  this.REGISTER_NAMES = REGISTER_NAMES;\n  this.REGISTER_NUMS = REGISTER_NUMS;\n  this.OPCODES = OPCODES;\n  this.OPS = OPS;\n\n};\n\nexport default CuteMachine;\n","import React from 'react';\nimport Table from 'react-bootstrap/Table'\nimport Container from 'react-bootstrap/Container'\nimport Row from 'react-bootstrap/Row'\nimport Col from 'react-bootstrap/Col'\nimport Button from 'react-bootstrap/Button'\nimport InputGroup from 'react-bootstrap/InputGroup'\nimport FormControl from 'react-bootstrap/FormControl'\nimport Badge from 'react-bootstrap/Badge'\n\nimport CuteMachine from './cute';\nconst Assemble = require('./assembler');\n\n\n\nconst EXAMPLE_PROGRAMS = require('./example_programs');\n\nconst STYLES = {\n    ripBgColor: 'LavenderBlush',\n    ripColor: 'black',\n    tableHeaderColor: 'ivory',\n    rspBgColor: 'lavender',\n    rbpBgColor: 'Moccasin',\n};\n\nclass MachineStateView extends React.Component {\n    constructor(props) {\n        super(props);\n        const memory = new Array(1024).fill(0);\n        this.machine = new CuteMachine(memory, alert);\n        this.numAddrsToDisplay = 128;\n        this.numBytesPerRow = 16;\n        this.state = {\n            memory: memory,\n            memDisplayStartAddr: 0,\n            registers: this.machine.registers,\n            source: '',\n            asmArea: '',\n            loadAddr: 0,\n            disasmTokens: [],\n            disasmIsFresh: false,\n            docInstr: -1,\n        };\n\n    }\n\n    memSet(addr, val) {\n        val = parseInt(val);\n        if (isNaN(val)) { val = 0; }\n        this.machine.memory[addr] = val;\n        this.setState({ memory: this.machine.memory, disasmIsFresh: false });\n    }\n\n    regSet(num, val) {\n        val = parseInt(val);\n        if (isNaN(val)) { val = 0; }\n        this.machine.registers[num] = val;\n        this.setState({ registers: this.machine.registers });\n    }\n\n    setLoadAddr(val) {\n        val = parseInt(val);\n        if (isNaN(val) || val >= this.machine.memory.length) { val = 0; }\n        /* Changing load address invalidates disassembly */\n        this.setState({ loadAddr: val, disasmIsFresh: false });\n    }\n\n    run() {\n        this.machine.execute();\n        this.setState({ registers: this.machine.registers, memory: this.machine.memory });\n    }\n\n    step() {\n        this.machine.executeStep();\n        this.setState({ registers: this.machine.registers, memory: this.machine.memory });\n    }\n\n    inspectAddr(val) {\n        val = parseInt(val);\n        if (isNaN(val)) return;\n        if (val < 0 || val >= this.machine.memory.length) return;\n        this.setState({ memDisplayStartAddr: val });\n    }\n\n    asmAreaEdit(e) {\n        this.setState({ asmArea: e });\n    }\n\n    assemble() {\n        let tokens = [];\n        try {\n            tokens = Assemble(this.machine, this.state.asmArea, this.state.loadAddr);\n            this.machine.registers[this.machine.REGISTER_NUMS['RSP']] = (this.state.loadAddr || 0) + tokens.length + 1;\n            this.machine.registers[this.machine.REGISTER_NUMS['RBP']] = this.machine.registers[this.machine.REGISTER_NUMS['RSP']];\n            console.log(this.state.registers)\n            this.setState({ registers: this.machine.registers, memory: this.machine.memory, disasmTokens: tokens, disasmIsFresh: true });\n\n        } catch (e) {\n            alert(e);\n            this.setState({ registers: this.machine.registers, memory: this.machine.memory, disasmTokens: [], disasmIsFresh: false });\n\n        }\n    }\n\n    memPrev() {\n        let newAddr = this.state.memDisplayStartAddr - this.numAddrsToDisplay;\n        if (newAddr < 0) newAddr = 0;\n        this.setState({ memDisplayStartAddr: newAddr });\n\n    }\n\n    memNext() {\n        const newAddr = this.state.memDisplayStartAddr + this.numAddrsToDisplay;\n        if (newAddr >= this.machine.memory.length) return;\n        this.setState({ memDisplayStartAddr: newAddr });\n\n    }\n\n    availableInstrs() {\n        const instrs = [];\n        for (const [code, meta] of Object.entries(this.machine.OPCODES)) {\n            instrs.push({ name: meta.name, opCode: code, desc: meta.desc });\n        }\n        return instrs;\n    }\n\n    render() {\n        const bytes = this.state.memory.slice(this.state.memDisplayStartAddr,\n            this.state.memDisplayStartAddr + this.numAddrsToDisplay);\n        const memTable = [];\n        const ripValueAdj = this.state.registers[this.machine.REGISTER_NUMS.RIP] - this.state.memDisplayStartAddr;\n        const rspValueAdj = this.state.registers[this.machine.REGISTER_NUMS.RSP] - this.state.memDisplayStartAddr;\n        const rbpValueAdj = this.state.registers[this.machine.REGISTER_NUMS.RBP] - this.state.memDisplayStartAddr;\n        bytes.forEach((_, i) => {\n            if (i % this.numBytesPerRow !== 0) return;\n            let cols = [];\n            for (let i = 0; i < this.numBytesPerRow; i++) { cols.push(i); }\n            memTable.push(\n                <tr key={`row-${i}`}>\n                    <td style={{ backgroundColor: STYLES.tableHeaderColor }}>{this.state.memDisplayStartAddr + i}</td>\n                    {cols.map(\n                        offset => {\n                            const addr = i + offset;\n                            const isRip = ripValueAdj === addr;\n                            const isRsp = rspValueAdj === addr;\n                            const isRbp = rbpValueAdj === addr;\n                            const dynaColor = isRip ? STYLES.ripBgColor : (isRsp ? STYLES.rspBgColor : (isRbp ? STYLES.rbpBgColor : ''));\n                            const absoluteAddr = addr + this.state.memDisplayStartAddr;\n                            const disasmAvailable = this.state.disasmIsFresh\n                                && absoluteAddr >= this.state.loadAddr\n                                && absoluteAddr < (this.state.loadAddr + this.state.disasmTokens.length);\n\n\n                            return <td key={`mem-${i + offset}`}\n                                style={{ backgroundColor: dynaColor, overflow: 'hidden' }}>\n                                {disasmAvailable ? <div className=\"disasm\">{this.state.disasmTokens[absoluteAddr - this.state.loadAddr]}</div> : ''}\n                                <input\n                                    type=\"text\"\n                                    style={{\n                                        width: '100%', border: 'none',\n                                        backgroundColor: dynaColor,\n                                    }}\n                                    onChange={e => this.memSet(i + offset, e.target.value)}\n                                    value={bytes[i + offset]}\n                                    disabled={i + offset + this.state.memDisplayStartAddr >= this.state.memory.length}\n                                /> </td>\n\n                        })}\n                </tr>\n            );\n        });\n\n        return <div className=\"monospaced\">  {/* <<  Flip this as needed */}\n            <Container>\n                <Row style={{ textAlign: \"center\" }}>\n                    <Col md={2}>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>CPU</b></Col></Row>\n                        <Table bordered responsive size=\"sm\">\n                            <tbody>\n                                {this.state.registers.map((value, i) => {\n                                    const isRip = this.machine.REGISTER_NAMES[i] === 'RIP';\n                                    const isRsp = this.machine.REGISTER_NAMES[i] === 'RSP';\n                                    const isRbp = this.machine.REGISTER_NAMES[i] === 'RBP';\n                                    const dynaColor = isRip ? STYLES.ripBgColor : (isRsp ? STYLES.rspBgColor : (isRbp ? STYLES.rbpBgColor : ''));\n                                    return <tr key={`reg-row-${i}`}>\n                                        <td style={{ backgroundColor: STYLES.tableHeaderColor }}>{this.machine.REGISTER_NAMES[i]}</td>\n                                        <td key={`mem-${i}`} style={{ backgroundColor: dynaColor }}>\n                                            <input type=\"text\"\n                                                style={{ width: '100%', border: 'none', backgroundColor: dynaColor }}\n                                                value={value}\n                                                onChange={e => this.regSet(i, e.target.value)} /></td>\n                                    </tr>\n                                })}\n                            </tbody>\n                        </Table>\n                        <Row>\n                            <Col>\n                                <Button variant=\"light\" onClick={() => this.run()}>Run</Button>\n                                <Button style={{ marginLeft: '2px' }} variant=\"light\" onClick={() => this.step()}>Step</Button>\n                            </Col>\n                        </Row>\n                    </Col>\n                    <Col md={10}>\n                        <Col md={12}>\n                            <Row><Col style={{ marginBottom: '10px' }}><b>Memory</b></Col></Row>\n                            <Table bordered responsive size=\"sm\">\n                                <tbody>\n                                    {memTable}\n                                </tbody>\n                            </Table>\n                            <Row style={{ marginBottom: '5px', marginLeft: '5px' }}>\n                                <Button variant=\"light\" onClick={() => this.memPrev()}> {'<'} </Button>\n                                <Button style={{ marginLeft: '2px' }} variant=\"light\" onClick={() => this.memNext()}> {'>'} </Button>\n                                <input type=\"text\" style={{ border: 'solid 1px lightgray', marginLeft: '15px', paddingLeft: '10px' }} onChange={(e) => this.inspectAddr(e.target.value)} placeholder=\"Go to address\" />\n                            </Row>\n                        </Col>\n                    </Col>\n                </Row>\n\n                <hr />\n\n                <Row style={{ textAlign: \"center\", marginTop: '10px' }}>\n                    <Col sm={6}>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>Assembler</b></Col></Row>\n                        <Row>\n                            <textarea placeholder=\"Assembly Editor\"\n                                style={{ width: '100%', height: '100%', minHeight: '220px', paddingLeft: '10px', borderColor: 'lightgray' }}\n                                value={this.state.asmArea}\n                                onChange={e => this.asmAreaEdit(e.target.value)} />\n                        </Row>\n                        <Row>\n                            <Col sm={12}>\n                                <InputGroup style={{ marginTop: '5px' }}>\n                                    <FormControl\n                                        onChange={(e) => this.setLoadAddr(e.target.value)}\n                                        placeholder=\"Address to load program at (Default = 0)\"\n                                    />\n                                    <InputGroup.Append>\n                                        <Button variant=\"info\" onClick={() => this.assemble()}>Load</Button>\n                                    </InputGroup.Append>\n                                </InputGroup>\n                            </Col>\n                        </Row>\n                    </Col>\n\n\n                    <Col sm={6}>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>Example Programs</b></Col></Row>\n                        <Row>\n                            <Col sm={12} style={{ overflowY: 'scroll' }}>\n                                <h5>\n                                    {EXAMPLE_PROGRAMS.map((p, i) => <a key={`example-prog-${i}`} onClick={() => this.setState({ asmArea: p.source })}><Badge className=\"instrDocBtn\" pill variant=\"light\">{p.name}</Badge>{' '}</a>)}\n                                </h5>\n                            </Col>\n                        </Row>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>Instruction Set</b></Col></Row>\n                        <Row>\n                            <Col sm={12} style={{ overflowY: 'scroll' }}>\n                                <h5>\n                                    {this.availableInstrs().map((instr, i) => <a key={`instrdoc-${i}`} onClick={()=>this.setState({docInstr: i})}><Badge className=\"instrDocBtn\" pill variant={this.state.docInstr === i ? 'primary' : 'light'}>{instr.name}</Badge>{' '}</a>)}\n                                </h5>\n                                <br/>\n                                { this.state.docInstr === -1 ? '' : this.availableInstrs()[this.state.docInstr].desc}\n                            </Col>\n                        </Row>\n                    </Col>\n\n                </Row>\n            </Container>\n        </div >\n    };\n\n};\n\nexport default MachineStateView;","import 'bootstrap/dist/css/bootstrap.min.css';\nimport MachineStateView from './MachineStateView';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <br/><br/>\n          <MachineStateView/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}