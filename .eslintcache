[{"/workspaces/cute/src/reportWebVitals.js":"1","/workspaces/cute/src/cute.js":"2","/workspaces/cute/src/App.js":"3","/workspaces/cute/src/assembler.js":"4","/workspaces/cute/src/MachineStateView.js":"5","/workspaces/cute/src/example_programs.js":"6","/workspaces/cute/src/index.js":"7"},{"size":362,"mtime":1619322676585,"results":"8","hashOfConfig":"9"},{"size":17507,"mtime":1619334590509,"results":"10","hashOfConfig":"9"},{"size":259,"mtime":1619322676585,"results":"11","hashOfConfig":"9"},{"size":4868,"mtime":1619328647115,"results":"12","hashOfConfig":"9"},{"size":12723,"mtime":1619334779669,"results":"13","hashOfConfig":"9"},{"size":1999,"mtime":1619331486718,"results":"14","hashOfConfig":"9"},{"size":500,"mtime":1619322676585,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"9m6xuu",{"filePath":"18","messages":"19","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"/workspaces/cute/src/reportWebVitals.js",[],"/workspaces/cute/src/cute.js",["33","34","35","36","37","38"],"const REGISTER_NAMES = {\n  0 : 'R0',\n  1 : 'R1',\n  2 : 'R2',\n  3 : 'R3',\n  4 : 'R4',\n  5 : 'RRA',\n  6 : 'RBP',\n  7 : 'RSP',\n  8 : 'RIP',\n};\n\n// Reverse mapping of REGISTER_NAMES\nconst REGISTER_NUMS = {};\nfor (let num in REGISTER_NAMES) {\n  REGISTER_NUMS[REGISTER_NAMES[num]] = num;\n}\n\nconst OPCODES = {\n  0: { name: 'HALT', args: 0, desc: 'Args: none  -  Stops execution of the program here. Does not advance IP' },\n  1: { name: 'ADD', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 + Reg2' },\n  2: { name: 'ADDI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg + Immediate' },\n  3: { name: 'SUB', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 - Reg2'  },\n  4: { name: 'SUBI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg - Immediate' },\n  // 5: { name: 'ASSERT', args: 1 , desc: '' },\n  6: { name: 'LABEL', args: 1 , desc: 'Args: <Label>  -  Creates a label with given name, pointing to next instruction' },\n  7: { name: 'JMPL', args: 1 , desc: 'Args: <Label> - Unconditional jump to the label with given name' },\n  8: { name: 'JMPGT', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 > Reg2' },\n  9: { name: 'JMPGTE', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 >= Reg2' },\n  10: { name: 'JMPEQ', args: 3 , desc: 'Args: <Reg1> <Reg2> <Immediate> - Conditional jump to Immediate address if Reg1 equals Reg2' },\n  11: { name: 'PRINT', args: 1 , desc: 'Args: <Reg> - Print the value of Reg' },\n  12: { name: 'SETI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Immediate' },\n  13: { name: 'JMPI', args: 1 , desc: 'Args:  <Address> - Unconditional jump to Address' },\n  14: { name: 'JMPEQI', args: 3 , desc: 'Args: <Reg> <Address1> <Address2> - If Reg = value at Address1, jump to Address2' },\n  15: { name: 'JMPEQIL', args: 3 , desc: 'Args: <Reg> <Address> <Label>  -  If value of Reg equals Immediate, jump to Label' },\n  16: { name: 'PRINTBYTE', args: 1 , desc: 'Args: <Reg> - PRINT, but Reg is a register contaiing address of byte to print' },\n  17: { name: 'DATA', args: 2, varLen: true , desc: 'VarArgs: <Label> <Length> [Bytes] - Defines static data of given Length, with given Label' },\n  // 18: { name: 'PRINTSTRL', args: 1 , desc: '' },\n  19: { name: 'PRINTBYTEI', args: 1 , desc: 'Args: <Immediate> - Prints ASCII character for the given immediate' },\n  20: { name: 'JMPEQL', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 = Reg2' },\n  21: { name: 'SET', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets value Reg1 to the value of Reg2' },\n  22: { name: 'JMPLT', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 < Reg2' },\n  23: { name: 'JMPLTE', args: 3 , desc: 'Args: <Reg1> <Reg2> <Label> - Conditional jump to Label if Reg1 <= Reg2' },\n  24: { name: 'LOAD', args: 2 , desc: 'Args: <Reg1> <Reg2> - Load byte at address held in Reg2 into Reg1' },\n  25: { name: 'PUSH', args: 1 , desc: 'Args: <Reg> - Pushes the value of Reg to the top of the stack (RSP) and increments RSP' },\n  26: { name: 'POP', args: 1 , desc: 'Args: <Reg>  - Places the value on top of the stack (RSP-1) into Reg and decrements RSP' },\n  27: { name: 'CALL', args: 1 , desc: 'Args: <Label>  -  Pushes RRA onto the stack, sets RRA to next instruction, and jumps to Label' },\n  28: { name: 'RET', args: 0 , desc: 'Args: None  -  Returns control to the instruction at address RRA. Restores RRA to previous RRA value, which is expected to be on top of the stack (RSP-1)' },\n  29: { name: 'CHDATA', args: 2, varLen: true , desc: 'Varargs: <Label> <Length> STRING - Like DATA, but var-length data arg is provided as a character string. Eg. - CHDATA letters 5 ABCDE' },\n  30: { name: 'STORE', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Stores value of Reg1 at address held in Reg2' },\n  31: { name: 'AOL', args: 2 , desc: 'Args: <Label> <Register>  -  Address-of-label instruction. Sets Register to address Label refers to' },\n  32: { name: 'STORI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Stores Immediate value at address held in Reg' },\n  33: { name: 'JMPNEQIL', args: 3 , desc: 'Args: <Reg> <Immediate> <Label>  -  If value of Reg does not equal Immediate, jump to Label' },\n  34: { name: 'MUL', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 * Reg2' },\n  35: { name: 'MULI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg * Immediate' },\n  36: { name: 'DIV', args: 2 , desc: 'Args: <Reg1> <Reg2>  -  Sets Reg1 to Reg1 / Reg2'  },\n  37: { name: 'DIVI', args: 2 , desc: 'Args: <Reg> <Immediate>  -  Sets Reg to Reg / Immediate' },\n  38: { name: 'PCALL', args: 1 , desc: 'Preserved call. Like CALL, but preserves all registers' },\n  39: { name: 'PRET', args: 0 , desc: 'RET equivalent for PCALL - restores all preserved registers' },\n\n\n};\n\nconst OPS = {\n  HALT : 0,\n  ADD : 1,\n  ADDI : 2,\n  SUB : 3,\n  SUBI : 4,\n  ASSERT : 5,\n  LABEL : 6,\n  JMPL : 7,\n  JMPGT : 8,\n  JMPGTE : 9,\n  JMPEQ : 10,\n  PRINT : 11,\n  SETI   : 12,\n  JMPI : 13,\n  JMPEQI : 14,\n  JMPEQIL : 15,\n  PRINTBYTE : 16,\n  DATA : 17, // DATA HELLOWORLD SIZE  'H' 'E'\n  PRINTSTRL : 18, // Print a string at a label\n  PRINTBYTEI : 19,\n  JMPEQL : 20,\n  SET : 21,\n  JMPLT: 22,\n  JMPLTE : 23,\n  LOAD: 24,\n  PUSH : 25,\n  POP : 26,\n  CALL : 27,\n  RET : 28,\n  CHDATA : 29,\n  STORE : 30,\n  AOL : 31,\n  STORI : 32,\n  JMPNEQIL: 33,\n  MUL : 34,\n  MULI : 35, \n  DIV : 36,\n  DIVI : 37,\n  PCALL : 38,\n  PRET : 39,\n};\n\nconst\n    HALT = 0,\n    ADD = 1,\n    ADDI = 2,\n    SUB = 3,\n    SUBI = 4,\n    ASSERT = 5,\n    LABEL = 6,\n    JMPL = 7,\n    JMPGT = 8,\n    JMPGTE = 9,\n    JMPEQ = 10,\n    PRINT = 11,\n    SETI   = 12,\n    JMPI = 13,\n    JMPEQI = 14,\n    JMPEQIL = 15,\n    PRINTBYTE = 16,\n    DATA = 17, // DATA HELLOWORLD SIZE  'H' 'E'\n    PRINTSTRL = 18, // Print a string at a label\n    PRINTBYTEI = 19,\n    JMPEQL = 20,\n    SET = 21,\n    JMPLT = 22,\n    JMPLTE = 23,\n    LOAD = 24,\n    PUSH = 25,\n    POP = 26,\n    CALL = 27,\n    RET = 28,\n    CHDATA = 29,\n    STORE = 30,\n    AOL = 31,\n    STORI = 32, \n    JMPNEQIL = 33,\n    MUL = 34,\n    MULI = 35, \n    DIV = 36,\n    DIVI = 37,\n    PCALL = 38,\n    PRET = 39;\n\nconst numArgs = [];\nObject.keys(OPCODES).forEach(k => numArgs[k] = OPCODES[k].args);\n\nconst registers = [0, 0, 0, 0, 0, 0, 0, 0];\nconst R0 = 0, R1 = 1, R2=2, R3=3, R4=4, RRA=5, RBP= 6, RSP=7, RIP=8;\n\n\nlet memory = [\n  SETI, R1, 1, JMPI, 8, ADDI, R1, 5, ADDI, R1, 8, PRINT, R1, LABEL, 'ADD3MORE', ADDI, R1, 3, PRINT, R1\n];\n\n// Let's try a hello world\nconst c =  char =>  char.charCodeAt(0);\nmemory = [\n  DATA, \"HW\", 11, c('H'), c('e'), c('l'), c('l'), c ('o'), c(' '), c('W'), c('o'), c('r'), c('l'), c('d'),\n  SETI, R0, 11, // Length of str\n  SETI, R1, 0,  // Curr idx in str\n  SETI, R2, 3,  // Address of start of string \n  LABEL, \"PRINTCHAR\",\n  SET, R3, R2, // R3 is a temp we used to calculate start of string + curr index\n  ADD, R3, R1,\n  PRINTBYTE, R3,\n  ADDI, R1, 1,\n  JMPEQL, R1, R0, \"DONE\",\n  JMPL, \"PRINTCHAR\",\n  LABEL, \"DONE\",\n  \n];\n\n\nfunction _execute(memory, registers, codeStart, codeEnd, oneStep, print) {\n  // Find labels and static data in the code\n  const _labels = {};\n  const _statics = {};\n  let currInstr = codeStart;\n  while (currInstr < codeEnd) {\n    const opCode = memory[currInstr];\n    if (opCode === LABEL) {\n      _labels[ memory[currInstr + 1] ] = currInstr + numArgs[opCode] + 1;\n      currInstr += numArgs[opCode] + 1;\n    } else if (opCode === DATA || opCode === CHDATA) {\n      const label =  memory[currInstr + 1]; \n      _statics[ label ] = currInstr  + 2; // label points to the size byte\n      currInstr +=  1 + 2 + memory[ _statics[label] ] ;\n    } else {\n      currInstr += numArgs[opCode] + 1;\n    }\n  }\n\n  // Execute\n  let lhs = 0, rhs = 0; // Utility vars\n  while (registers[RIP] < codeEnd) {\n    var rip = registers[RIP];\n    switch (memory[rip]) {\n      case HALT:\n        // registers[RIP] += numArgs[memory[rip]] + 1;\n        return;\n      case PRINT:\n        print(registers[memory[rip + 1]]);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case ADD: // Adds two registers\n        registers[memory[rip + 1]] += registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case ADDI:\n        registers[memory[rip + 1]] += memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SUB: \n        registers[memory[rip + 1]] -= registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SUBI:\n        registers[memory[rip + 1]] -= memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case MUL: \n        registers[memory[rip + 1]] *= registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case MULI:\n        registers[memory[rip + 1]] *= memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case DIV: \n        rhs = registers[memory[rip + 2]];\n        if (rhs === 0) { alert('SIGFPE - division by 0'); return; }\n        registers[memory[rip + 1]] = Math.floor(registers[memory[rip + 1]] / rhs);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case DIVI:\n        rhs = memory[rip + 2];\n        if (rhs === 0) { alert('SIGFPE - division by 0'); return; }\n        registers[memory[rip + 1]] = Math.floor(registers[memory[rip + 1]] / rhs);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SET:\n        registers[memory[rip + 1]] = registers[memory[rip + 2]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case SETI:\n        registers[memory[rip + 1]] = memory[rip + 2];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case JMPI:\n        registers[RIP] = memory[rip + 1];\n        break;\n      case JMPL:\n        registers[RIP] = _labels[memory[rip + 1]];\n        break;\n      case LABEL:\n        // noop\n       registers[RIP] += 2;\n       break;\n      case JMPEQ:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs === rhs) {\n          registers[RIP] = memory[rip + 3];\n        } else {\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n        break;\n      case JMPEQI:\n        lhs = registers[memory[rip + 1]];\n        rhs = memory[rip + 2];\n        if (lhs === rhs) {\n          registers[RIP] = memory[rip + 3];\n        } else {\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case JMPGT:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs > rhs) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n       case JMPGTE:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs >= rhs) {\n          registers[RIP] = registers[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n       case JMPLT:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs < rhs) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n        break;\n       case JMPLTE:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[memory[rip + 2]];\n        if (lhs <= rhs) {\n          registers[RIP] = registers[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case JMPEQIL:\n      case JMPNEQIL:\n        lhs = registers[memory[rip + 1]];\n        rhs = memory[rip + 2];\n        let truthy = memory[rip] === JMPEQIL ? lhs === rhs : lhs !== rhs;\n        if (truthy) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case AOL:  // AOL label register\n        // Puts the address of label label in register\n        let addr = _statics[memory[rip + 1]];\n        if (addr === undefined) {\n          addr = _labels[memory[rip + 1]];\n        } // TODO: labels and statics can be one case\n        registers[memory[rip + 2]] = addr;\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case JMPEQL:\n        lhs = registers[memory[rip + 1]];\n        rhs = registers[ memory[rip + 2] ];\n        if (lhs === rhs) {\n          registers[RIP] = _labels[memory[rip + 3]];\n        } else {\n          registers[RIP] += numArgs[memory[rip]] + 1;\n        }\n       break;\n      case PRINTBYTEI:\n        print(String.fromCharCode( memory[rip + 1]  ) );\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case PRINTBYTE:\n        const byteToPrint = memory[registers[ memory[rip+1] ] ]; // Arg is a register contaiing address of byte to print\n        print( String.fromCharCode( byteToPrint  ) );\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case DATA:\n      case CHDATA:\n        // Noop\n        const label =  memory[rip + 1]; \n        registers[RIP] +=  2 + memory[ _statics[label] ]  +  1 ; // label, size, num of chars, +1 offset\n        break;\n      case LOAD:\n        registers[memory[rip+1]] = memory[registers[memory[rip+2]]];\n        console.log(`Load ${memory[registers[memory[rip+2]]]} into R${memory[rip+1]}`);\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case STORE: // Store value of first arg (reg) into memory pointed to by second ard\n        memory[registers[memory[rip+2]]] = registers[memory[rip+1]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case STORI: // Store value of first arg (reg) into memory pointed to by second ard\n        memory[registers[memory[rip+2]]] = memory[rip+1];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case PUSH:\n        memory[registers[RSP]++] = registers[memory[rip+1]];\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case POP:\n        const topOfStack = registers[RSP] - 1;\n        registers[memory[rip+1]] = memory[topOfStack];\n        registers[RSP] = topOfStack;\n        registers[RIP] += numArgs[memory[rip]] + 1;\n        break;\n      case CALL:\n        // First push RRA to stack\n        memory[registers[RSP]++] = registers[RRA];\n        // Write addr of next instruction to RRA\n        registers[RRA] = registers[RIP] + numArgs[memory[rip]] + 1;\n        // Jump to label\n        registers[RIP] = _labels[memory[rip + 1]];\n        break;\n      case RET:\n        // Pop stack RA into RRA, then jump there\n        const ra = registers[RRA];\n        registers[RRA] = memory[--registers[RSP]];\n        registers[RIP] = ra;\n        break;\n      case PCALL:\n        // Write addr of next instruction to RIP - we'll preserve this\n        registers[RIP] = registers[RIP] + numArgs[memory[rip]] + 1;\n        const registerStateAtCallTime = [...registers];\n\n        // Everything between [RBP and RSP) is an arg\n        let pcall_args = [];\n        for (let i = registers[RBP]; i < registers[RSP]; i++) {\n          pcall_args.push(memory[i]);\n        }\n\n        // This is important because when we restore RSP, we don't how how many args were provided for the call.\n        // Setting it 'minus args' here will let us simply increment by the number of return values in PRET.\n        registerStateAtCallTime[RSP] -= pcall_args.length;\n\n        // Preserve registers\n        for (let i = 0; i < registerStateAtCallTime.length; i++) {\n          memory[registers[RBP] + i] = registerStateAtCallTime[i];\n        }\n\n        // BP is where first arg sits\n        // Put args on top\n        for (let i = 0; i < pcall_args.length; i++) {\n          memory[registers[RBP] + registers.length + i ] = pcall_args[i];\n        }\n\n        registers[RBP] = registers[RBP] + registers.length;\n        registers[RSP] = registers[RSP] + registers.length;\n\n        pcall_args.splice(0, pcall_args.length);\n\n        // Jump to label\n        registers[RIP] = _labels[memory[rip + 1]];\n        break;\n      case PRET:\n        const registerStateAtReturnTime = [...registers];\n        // Gather retvals\n        let retVals = [];\n        for (let i = registerStateAtReturnTime[RBP]; i < registerStateAtReturnTime[RSP]; i++) {\n          retVals.push(memory[i]);\n        }\n\n        // Restore regs\n        for (let i = 0; i < registerStateAtReturnTime.length; i++) {\n          registers[i] = memory[ registerStateAtReturnTime[RBP] - registers.length + i ];\n        }\n        // Push retvals and adjust SP\n        retVals.forEach(v => {\n          memory[registers[RSP]] = v;\n          registers[RSP]++;\n        });\n\n        retVals.splice(0, retVals.length);\n\n        break;\n    }\n\n    if (oneStep) break;\n  } \n}\n\n// execute(0, memory.length);\n\nfunction CuteMachine(memory, print=console.log) {\n  this.registers = [0, 0, 0, 0, 0, 0, 64, 64, 0];\n  this.memory = memory;\n  this.print=print;\n\n  this.execute = () => _execute(this.memory, this.registers, 0, this.memory.length, false, print);\n  this.executeStep = () => _execute(this.memory, this.registers, 0, this.memory.length, true, print);\n  this.setIp = (val) => this.registers[ this.REGISTER_NUMS['RIP'] ] = val;\n\n  this.REGISTER_NAMES = REGISTER_NAMES;\n  this.REGISTER_NUMS = REGISTER_NUMS;\n  this.OPCODES = OPCODES;\n  this.OPS = OPS;\n\n};\n\nexport default CuteMachine;\n","/workspaces/cute/src/App.js",[],"/workspaces/cute/src/assembler.js",["39","40","41","42","43","44"],"/workspaces/cute/src/MachineStateView.js",["45","46"],"import React from 'react';\nimport Table from 'react-bootstrap/Table'\nimport Container from 'react-bootstrap/Container'\nimport Row from 'react-bootstrap/Row'\nimport Col from 'react-bootstrap/Col'\nimport Button from 'react-bootstrap/Button'\nimport InputGroup from 'react-bootstrap/InputGroup'\nimport FormControl from 'react-bootstrap/FormControl'\nimport Badge from 'react-bootstrap/Badge'\n\nimport CuteMachine from './cute';\nconst Assemble = require('./assembler');\n\n\n\nconst EXAMPLE_PROGRAMS = require('./example_programs');\n\nconst STYLES = {\n    ripBgColor: 'LavenderBlush',\n    ripColor: 'black',\n    tableHeaderColor: 'ivory',\n    rspBgColor: 'lavender',\n    rbpBgColor: 'Moccasin',\n};\n\nclass MachineStateView extends React.Component {\n    constructor(props) {\n        super(props);\n        const memory = new Array(1024).fill(0);\n        this.machine = new CuteMachine(memory, alert);\n        this.numAddrsToDisplay = 128;\n        this.numBytesPerRow = 16;\n        this.state = {\n            memory: memory,\n            memDisplayStartAddr: 0,\n            registers: this.machine.registers,\n            source: '',\n            asmArea: '',\n            loadAddr: 0,\n            disasmTokens: [],\n            disasmIsFresh: false,\n            docInstr: -1,\n        };\n\n    }\n\n    memSet(addr, val) {\n        val = parseInt(val);\n        if (isNaN(val)) { val = 0; }\n        this.machine.memory[addr] = val;\n        this.setState({ memory: this.machine.memory, disasmIsFresh: false });\n    }\n\n    regSet(num, val) {\n        val = parseInt(val);\n        if (isNaN(val)) { val = 0; }\n        this.machine.registers[num] = val;\n        this.setState({ registers: this.machine.registers });\n    }\n\n    setLoadAddr(val) {\n        val = parseInt(val);\n        if (isNaN(val) || val >= this.machine.memory.length) { val = 0; }\n        /* Changing load address invalidates disassembly */\n        this.setState({ loadAddr: val, disasmIsFresh: false });\n    }\n\n    run() {\n        this.machine.execute();\n        this.setState({ registers: this.machine.registers, memory: this.machine.memory });\n    }\n\n    step() {\n        this.machine.executeStep();\n        this.setState({ registers: this.machine.registers, memory: this.machine.memory });\n    }\n\n    inspectAddr(val) {\n        val = parseInt(val);\n        if (isNaN(val)) return;\n        if (val < 0 || val >= this.machine.memory.length) return;\n        this.setState({ memDisplayStartAddr: val });\n    }\n\n    asmAreaEdit(e) {\n        this.setState({ asmArea: e });\n    }\n\n    assemble() {\n        let tokens = [];\n        try {\n            tokens = Assemble(this.machine, this.state.asmArea, this.state.loadAddr);\n            this.machine.registers[this.machine.REGISTER_NUMS['RSP']] = (this.state.loadAddr || 0) + tokens.length + 1;\n            this.machine.registers[this.machine.REGISTER_NUMS['RBP']] = this.machine.registers[this.machine.REGISTER_NUMS['RSP']];\n            console.log(this.state.registers)\n            this.setState({ registers: this.machine.registers, memory: this.machine.memory, disasmTokens: tokens, disasmIsFresh: true });\n\n        } catch (e) {\n            alert(e);\n            this.setState({ registers: this.machine.registers, memory: this.machine.memory, disasmTokens: [], disasmIsFresh: false });\n\n        }\n    }\n\n    memPrev() {\n        let newAddr = this.state.memDisplayStartAddr - this.numAddrsToDisplay;\n        if (newAddr < 0) newAddr = 0;\n        this.setState({ memDisplayStartAddr: newAddr });\n\n    }\n\n    memNext() {\n        const newAddr = this.state.memDisplayStartAddr + this.numAddrsToDisplay;\n        if (newAddr >= this.machine.memory.length) return;\n        this.setState({ memDisplayStartAddr: newAddr });\n\n    }\n\n    availableInstrs() {\n        const instrs = [];\n        for (const [code, meta] of Object.entries(this.machine.OPCODES)) {\n            instrs.push({ name: meta.name, opCode: code, desc: meta.desc });\n        }\n        return instrs;\n    }\n\n    render() {\n        const bytes = this.state.memory.slice(this.state.memDisplayStartAddr,\n            this.state.memDisplayStartAddr + this.numAddrsToDisplay);\n        const memTable = [];\n        const ripValueAdj = this.state.registers[this.machine.REGISTER_NUMS.RIP] - this.state.memDisplayStartAddr;\n        const rspValueAdj = this.state.registers[this.machine.REGISTER_NUMS.RSP] - this.state.memDisplayStartAddr;\n        const rbpValueAdj = this.state.registers[this.machine.REGISTER_NUMS.RBP] - this.state.memDisplayStartAddr;\n        bytes.forEach((_, i) => {\n            if (i % this.numBytesPerRow !== 0) return;\n            let cols = [];\n            for (let i = 0; i < this.numBytesPerRow; i++) { cols.push(i); }\n            memTable.push(\n                <tr key={`row-${i}`}>\n                    <td style={{ backgroundColor: STYLES.tableHeaderColor }}>{this.state.memDisplayStartAddr + i}</td>\n                    {cols.map(\n                        offset => {\n                            const addr = i + offset;\n                            const isRip = ripValueAdj === addr;\n                            const isRsp = rspValueAdj === addr;\n                            const isRbp = rbpValueAdj === addr;\n                            const dynaColor = isRip ? STYLES.ripBgColor : (isRsp ? STYLES.rspBgColor : (isRbp ? STYLES.rbpBgColor : ''));\n                            const absoluteAddr = addr + this.state.memDisplayStartAddr;\n                            const disasmAvailable = this.state.disasmIsFresh\n                                && absoluteAddr >= this.state.loadAddr\n                                && absoluteAddr < (this.state.loadAddr + this.state.disasmTokens.length);\n\n\n                            return <td key={`mem-${i + offset}`}\n                                style={{ backgroundColor: dynaColor, overflow: 'hidden' }}>\n                                {disasmAvailable ? <div className=\"disasm\">{this.state.disasmTokens[absoluteAddr - this.state.loadAddr]}</div> : ''}\n                                <input\n                                    type=\"text\"\n                                    style={{\n                                        width: '100%', border: 'none',\n                                        backgroundColor: dynaColor,\n                                    }}\n                                    onChange={e => this.memSet(i + offset, e.target.value)}\n                                    value={bytes[i + offset]}\n                                    disabled={i + offset + this.state.memDisplayStartAddr >= this.state.memory.length}\n                                /> </td>\n\n                        })}\n                </tr>\n            );\n        });\n\n        return <div className=\"monospaced\">  {/* <<  Flip this as needed */}\n            <Container>\n                <Row style={{ textAlign: \"center\" }}>\n                    <Col md={2}>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>CPU</b></Col></Row>\n                        <Table bordered responsive size=\"sm\">\n                            <tbody>\n                                {this.state.registers.map((value, i) => {\n                                    const isRip = this.machine.REGISTER_NAMES[i] === 'RIP';\n                                    const isRsp = this.machine.REGISTER_NAMES[i] === 'RSP';\n                                    const isRbp = this.machine.REGISTER_NAMES[i] === 'RBP';\n                                    const dynaColor = isRip ? STYLES.ripBgColor : (isRsp ? STYLES.rspBgColor : (isRbp ? STYLES.rbpBgColor : ''));\n                                    return <tr key={`reg-row-${i}`}>\n                                        <td style={{ backgroundColor: STYLES.tableHeaderColor }}>{this.machine.REGISTER_NAMES[i]}</td>\n                                        <td key={`mem-${i}`} style={{ backgroundColor: dynaColor }}>\n                                            <input type=\"text\"\n                                                style={{ width: '100%', border: 'none', backgroundColor: dynaColor }}\n                                                value={value}\n                                                onChange={e => this.regSet(i, e.target.value)} /></td>\n                                    </tr>\n                                })}\n                            </tbody>\n                        </Table>\n                        <Row>\n                            <Col>\n                                <Button variant=\"light\" onClick={() => this.run()}>Run</Button>\n                                <Button style={{ marginLeft: '2px' }} variant=\"light\" onClick={() => this.step()}>Step</Button>\n                            </Col>\n                        </Row>\n                    </Col>\n                    <Col md={10}>\n                        <Col md={12}>\n                            <Row><Col style={{ marginBottom: '10px' }}><b>Memory</b></Col></Row>\n                            <Table bordered responsive size=\"sm\">\n                                <tbody>\n                                    {memTable}\n                                </tbody>\n                            </Table>\n                            <Row style={{ marginBottom: '5px', marginLeft: '5px' }}>\n                                <Button variant=\"light\" onClick={() => this.memPrev()}> {'<'} </Button>\n                                <Button style={{ marginLeft: '2px' }} variant=\"light\" onClick={() => this.memNext()}> {'>'} </Button>\n                                <input type=\"text\" style={{ border: 'solid 1px lightgray', marginLeft: '15px', paddingLeft: '10px' }} onChange={(e) => this.inspectAddr(e.target.value)} placeholder=\"Go to address\" />\n                            </Row>\n                        </Col>\n                    </Col>\n                </Row>\n\n                <hr />\n\n                <Row style={{ textAlign: \"center\", marginTop: '10px' }}>\n                    <Col sm={6}>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>Assembler</b></Col></Row>\n                        <Row>\n                            <textarea placeholder=\"Assembly Editor\"\n                                style={{ width: '100%', height: '100%', minHeight: '220px', paddingLeft: '10px', borderColor: 'lightgray' }}\n                                value={this.state.asmArea}\n                                onChange={e => this.asmAreaEdit(e.target.value)} />\n                        </Row>\n                        <Row>\n                            <Col sm={12}>\n                                <InputGroup style={{ marginTop: '5px' }}>\n                                    <FormControl\n                                        onChange={(e) => this.setLoadAddr(e.target.value)}\n                                        placeholder=\"Address to load program at (Default = 0)\"\n                                    />\n                                    <InputGroup.Append>\n                                        <Button variant=\"warning\" onClick={() => this.assemble()}>Load</Button>\n                                    </InputGroup.Append>\n                                </InputGroup>\n                            </Col>\n                        </Row>\n                    </Col>\n\n\n                    <Col sm={6}>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>Example Programs</b></Col></Row>\n                        <Row>\n                            <Col sm={12} style={{ overflowY: 'scroll' }}>\n                                <h5>\n                                    {EXAMPLE_PROGRAMS.map((p, i) => <a key={`example-prog-${i}`} onClick={() => this.setState({ asmArea: p.source })}><Badge className=\"instrDocBtn\" pill variant=\"light\">{p.name}</Badge>{' '}</a>)}\n                                </h5>\n                            </Col>\n                        </Row>\n                        <Row><Col style={{ marginBottom: '10px' }}><b>Instruction Set</b></Col></Row>\n                        <Row>\n                            <Col sm={12} style={{ overflowY: 'scroll' }}>\n                                <h5>\n                                    {this.availableInstrs().map((instr, i) => <a key={`instrdoc-${i}`} onClick={()=>this.setState({docInstr: i})}><Badge className=\"instrDocBtn\" pill variant={this.state.docInstr === i ? 'primary' : 'light'}>{instr.name}</Badge>{' '}</a>)}\n                                </h5>\n                                <br/>\n                                { this.state.docInstr === -1 ? '' : this.availableInstrs()[this.state.docInstr].desc}\n                            </Col>\n                        </Row>\n                    </Col>\n\n                </Row>\n            </Container>\n        </div >\n    };\n\n};\n\nexport default MachineStateView;","/workspaces/cute/src/example_programs.js",[],"/workspaces/cute/src/index.js",[],["47","48"],{"ruleId":"49","severity":1,"message":"50","line":113,"column":5,"nodeType":"51","messageId":"52","endLine":113,"endColumn":11},{"ruleId":"49","severity":1,"message":"53","line":126,"column":5,"nodeType":"51","messageId":"52","endLine":126,"endColumn":14},{"ruleId":"49","severity":1,"message":"54","line":152,"column":7,"nodeType":"51","messageId":"52","endLine":152,"endColumn":16},{"ruleId":"49","severity":1,"message":"55","line":153,"column":35,"nodeType":"51","messageId":"52","endLine":153,"endColumn":37},{"ruleId":"49","severity":1,"message":"56","line":162,"column":1,"nodeType":"51","messageId":"52","endLine":162,"endColumn":7},{"ruleId":"57","severity":1,"message":"58","line":202,"column":5,"nodeType":"59","messageId":"60","endLine":454,"endColumn":6},{"ruleId":"61","severity":1,"message":"62","line":7,"column":15,"nodeType":"63","messageId":"64","endLine":7,"endColumn":17},{"ruleId":"61","severity":1,"message":"62","line":11,"column":15,"nodeType":"63","messageId":"64","endLine":11,"endColumn":17},{"ruleId":"61","severity":1,"message":"62","line":14,"column":23,"nodeType":"63","messageId":"64","endLine":14,"endColumn":25},{"ruleId":"61","severity":1,"message":"62","line":14,"column":35,"nodeType":"63","messageId":"64","endLine":14,"endColumn":37},{"ruleId":"61","severity":1,"message":"62","line":66,"column":32,"nodeType":"63","messageId":"64","endLine":66,"endColumn":34},{"ruleId":"49","severity":1,"message":"65","line":128,"column":10,"nodeType":"51","messageId":"52","endLine":128,"endColumn":30},{"ruleId":"66","severity":1,"message":"67","line":252,"column":69,"nodeType":"68","endLine":252,"endColumn":151},{"ruleId":"66","severity":1,"message":"67","line":260,"column":79,"nodeType":"68","endLine":260,"endColumn":147},{"ruleId":"69","replacedBy":"70"},{"ruleId":"71","replacedBy":"72"},"no-unused-vars","'ASSERT' is assigned a value but never used.","Identifier","unusedVar","'PRINTSTRL' is assigned a value but never used.","'registers' is assigned a value but never used.","'R4' is assigned a value but never used.","'memory' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'memLoadWillOverwrite' is defined but never used.","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-native-reassign",["73"],"no-negated-in-lhs",["74"],"no-global-assign","no-unsafe-negation"]